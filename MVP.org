#+title: MVP

* Dialects
   Thanks—this fills in the gaps nicely. With the clarifications in `dialects.org`, here’s the concrete plan to get the network dialect rendering in App.tsx with flatten-js:

   1. **Network projection module**
      - Build a `network-dialect.ts` in `src/lib/james-algebra/` that walks a `FormNode` tree (reusing the stable ids) and produces a structure describing:
        - nodes: type (`round`/`square`/`angle`/`atom`), id, depth, siblings order
        - links: parent id → child id, supporting multi-links for structure sharing
      - Apply the canonical layout you specified: root at (0,0), each depth step moves downward by a fixed vertical spacing (e.g. `nodeSize * 2`), horizontal offsets based on sibling index so strands stay separate before merging.

   2. **Geometry synthesis with flatten-js**
      - For each node type, create the appropriate primitive:
        - circle radius 1cm for `round`
        - square of side 1cm for `square`
        - diamond (a square rotated 45°) with side 0.7cm for `angle`
        - atoms can be small circles or text placeholders; we’ll pick a simple geometry first.
      - Draw links as straight segments between node center points. Later we can curve them for aesthetics.
      - Collect everything into a `PlanarSet` so we can run hit-tests and spatial queries when interactivity arrives.

   3. **Structure sharing handling**
      - Start with one node per `FormId`. If two containers point to the same child id, the projection automatically draws multiple segments into that single node—matching the zipper/braid idea.
      - We can expose helpers to let the UI optionally “fuse” strands (i.e., adjust layout to overlay links) later, but the base representation already contains the necessary multi-links.

   4. **Angle bracket behavior**
      - Follow the theorems from `README.org` for link semantics; geometrically, the diamond nodes are placed at the correct depth and tie to their neighbors just like other containers.
      - Special transformations (reflection cancellation, etc.) will be rules on top of the same network graph.

   5. **Renderer integration**
      - Add a `NetworkView` component in `App.tsx` that:
        - takes the current `FormNode`
        - uses the projection module to get the `PlanarSet`
        - renders via flatten-js → SVG (either direct `planarSet.svg()` or feeding primitives into D3)
      - Wrap it with a simple viewport: root at top-center, auto-fit to available width (responsive).

   6. **Data contract for interactivity**
      - Each node/link in the projection will carry its `FormId`, depth, and bounding box so the UI can map pointer events back to the logical form.
      - That will plug directly into the selection model you outlined (action → select → confirm).

   I’ll start by implementing the projection + geometry builder, wire it into a React component, and then we can iterate on styling/interactivity. No more unknowns blocking the flatten-js view now.

* Claude's Plan :ARCHIVE:
** Plan

    in progress   Define MVP scope for POC
    pending       Design data model for James Forms
    pending       Implement core Logic Engine (James Algebra rules)
    pending       Build Geometry Kernel wrapper
    pending       Create basic Renderer with React + SVG
    pending       Wire up interaction model (select rule → apply)
    pending       Add simple examples and test cases

** Path to POC

   Based on your README, here's my recommendation for a **minimal proof-of-concept**:

*** Phase 1: Core Foundation (Start Here)
   **Goal**: Get one dialect working end-to-end with one transformation rule

   **MVP Scope**:
   1. **Single dialect**: Start with **1D parens** (simplest to parse and render)
   2. **Three computational axioms**: Dominion, Involution, Deep Pervasion
   3. **One form**: `((a))` → `a` (Involution)
   4. **No animation yet**: Just instant transformations
   5. **No server/database**: Pure client-side React app

   **Why this scope?**
   - Parens are the canonical representation - easiest to debug
   - Gets you through the full stack (Logic → Geometry → Render → Interaction)
   - You can validate the architecture before adding complexity

*** Phase 2: Implementation Order

   **1. Data Model First** (Critical!)
   ```typescript
   // Internal representation - closer to distinction networks
   type Form = Empty | Mark | Container

   // Or go textual first since you have good parens notation
   type FormAST = string // "(())" 
   ```

   **2. Logic Engine** 
   - **Skip tau-prolog for POC** - it's overkill and adds complexity
   - Start with simple pattern matching in TypeScript
   - Just implement the 3 computational axioms as functions
   - Example: `involution: (form: Form) => Form | null`

   **3. Renderer** (Quick Win)
   - **React + raw SVG** (not d3, not flatten-js yet)
   - For parens: just render nested rectangles
   - Get visual feedback ASAP

   **4. Geometry Kernel**
   - **Defer flatten-js until you need 2D boxes dialect**
   - For parens POC, you just need: box sizing, nesting positions
   - Can be 50 lines of TypeScript

   **5. Interaction**
   - Simplify: Click container → highlight applicable rules → click rule to apply
   - Skip "select rule first" for POC

*** Phase 3: What to Build First

   **Day 1: Static Rendering**
   ```
   [ ] Parse "(())" to AST
   [ ] Render nested boxes as SVG
   [ ] Display one form on screen
   ```

   **Day 2: One Transformation**
   ```
   [ ] Implement Involution pattern matcher
   [ ] Add "Apply Involution" button
   [ ] Update render on click
   ```

   **Day 3: Interactive Selection**
   ```
   [ ] Click to select sub-form
   [ ] Highlight where rule can apply
   [ ] Apply rule to selection
   ```

*** My Recommendations

   **Simplify Stack for POC**:
   - ❌ tau-prolog → ✅ TypeScript pattern matching
   - ❌ flatten-js → ✅ Simple box layout math
   - ❌ d3js → ✅ React + SVG
   - ❌ React Router → ✅ Single page component
   - ❌ Supabase → ✅ localStorage for examples

   **After POC Works**:
   - Then add flatten-js for 2D boxes dialect
   - Then add morphing animations
   - Then add tau-prolog if pattern matching gets complex
   - Then add server/database for sharing

*** Questions to Answer First

   1. **Form representation**: AST (tree) vs. distinction network (graph)?
      - Recommendation: Start with AST for parens, easier to pattern match
        - A :: Let's go for an AST first, sure.

      
   2. **Where does state live**: React state, Zustand, Redux?
      - Recommendation: useState for POC, Zustand if it grows
        - A :: I have never heard of Zustand before, but useState is certainly adequate.

   3. **Parser**: Hand-written or library?
      - Recommendation: 20-line recursive descent parser for parens
        - A :: Sure, but wdym recursive descent parser? I imagine for parens it's a simple matter as displaying HTML wrapped in interactivity..? But maybe that'd make transitioning to other things harder.

   Want me to scaffold the POC structure in the `poc/` directory? I can:
   1. Set up the data model types
   2. Create a simple parser for parens notation
   3. Build the basic React component structure
   4. Implement one transformation rule

   Or would you prefer to discuss the approach more first?
