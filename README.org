#+title: Readme


* Iconic Arithmetic
Based off the work by George Spencer Brown, William Bricken, and Jeffrey James. 
https://iconicmath.com/
https://wbricken.com/

* For Codex
** goal
valerie is designing a tech implementation of **james algebra**, which has multiple visual dialects (1d parens → 2d boxes/maps → 2d-3d paths/rooms → 3d blocks). entity counts are small (tens–hundreds), so performance is irrelevant; clarity, geometry, and morph animation matter most.

** key conclusions

**rendering**
- pick **one svg-based renderer**: either `react+svg` or `two.js (svg mode)`.
- skip pixi/konva/p5 unless doing future experiential/3d stuff.
  
**geometry kernels**

- **flatten-js**: handle polygons, boxes, networks, merges/splits. pairs neatly with d3/svg.
- **bezier-js**: handle curved “path” dialect; proper bezier math + handles.
- optional: **clipper2-wasm** if you later need robust polygon offsets.
  
**what to avoid**
- d3 (alone), pixi, konva, p5 all lack solid boolean geometry; fine for drawing only.
  - d3 alone is mostly for rendering and is insufficient alone for the geometric animations i want. after finding flatten-js, i found it best supports d3js for its rendering.
- paper.js too heavyweight unless you want full editor scaffolding.
  
**morph animation strategy**

1. normalize path orientation/winding.
2. resample both shapes to N evenly spaced points (arc-length).
3. align start points to minimize total distance.
4. interpolate points (lerp) → rebuild svg path each frame.
5. for split/merge, manage ghost points / progressive re-sampling.

**architecture**

- **core algebra** (rewrite logic) → **geometry kernel** (flatten/bezier) → **renderer adapter** (svg).
- one morph/tween module reused across dialects.
- kernels hidden behind small interface: `union`, `subtract`, `sample`, `closestPoint`, `tween`.

** tl;dr

→ keep a single svg renderer
→ use **flatten-js** for straight geometry
→ use **bezier-js** for curved dialects
→ animate via resampling and point interpolation
→ reserve konva/pixi/godot for later experiential modes

* System Design
** James Algebra
*** Core Concepts
A form of "iconic" arithmetic, this is mathematics that looks like what it means. There are only shapes, no operators nor operands.

#+begin_quote
Concepts

void

- Void has no properties. (Nothing is not something.)
- Form is either not nothing or an illusion.
- Void-equivalent iorms may vary in structure but not in relevance.
- Void-equivalent forms are syntactically inert and semantically irrelevant.

Containers
- Containers represent distinctions.
- Everything is a container.
- There is only one relation, contains.
- Empty containers are units.
- Containers are both object and process.

Structure

- Forms are patterns of containment.
- Valid forms can be constructed physically.
- Forms can be represented in many multi-dimensional notations. Containers do not support sequence.
- Containers are not limited to a specific capacity (no anty).
- The contents of any container are mutually independent.

Axioms

- Axioms subdivide existent forms into discrete groups.
- Axioms do not make existent forms void-equivalent, and vice versa. All canonical forms are unequal.

Equality

- Containers with equal contents are equal.
- Equals can be substituted for equals.
- Removing identical outer boundaries maintains equality.
- Removing equal contents maintains equality.
- Equality is quantized dynamically by transformation steps.
- Forms change meaning only when they cross a boundary.

Arithmetic

- To count is to identify, categorize, indicate, fuse, and label.
- Addition is putting forms into the same container.
- Multiplication is putting square forms into a round container. Exponential and logarithmic bases are defined by the interpretation. Inverses are represented by the same boundary in different contexts.

#+end_quote

*** Axioms
**** Arithmetic
#+begin_example
existence
() != void

unit accumulation
() () != ()

void inversion
([]) = [()] = void

unit reflection
<()> () = void
#+end_example

**** Algebra
#+begin_example
inversion (enfold / clarify)
([A]) = [(A)] = A

arrangement (collect / disperse)
(A [B C]) = (A [B])(A [C])

reflection (create / cancel)
A <A> = void
#+end_example

**** Theorems

#+begin_example
Frame Theorems

dominion (emit / absorob)
(A []) = void

indication (unmark / mark)
([A][o]) = A

replication (replicate / tally)
([A]][o ...n... o]) = A ...N... A


Reflection Theorems

involution (wrap / unwrap)
<<A>> = A

separation
<A><B> = <A B>

reaction
<A <B>> = <A> B

promotion (demote/promote)
(A  [<B>] ) = <(A  [B] )>
(A <[<B>]>) = <(A <[B]>)>

#+end_example

*** Thoughts on computational implementation
The network dialect described below - a D.A.G. with shared structure - is certainly the most tractable. Distinction Networks are closely related as they are for a simpler formal system, but I am including it because it will be useful for you.
**** Network Dialect
#+begin_quote
Network Dialect
The network dialect (Figure 13-6) is certainly the
most computationally tractable. It provides the image
oi nodes/locations/processors with links/paths/wires
between them. Each link is a contains relation, so that
the relational structure is explicit. Networks and other
relational dialects have an additional display requirement
to specify the direction of nesting, from shallowest to
deepest. The network version often presumes a gravi¬
tational metaphor, with deeper nesting shown at lower
levels. For a network the level of nesting is defined by
counting the nodes lying between beginning and goal
(input and output).
Networks are a well-established modeling tool in compu¬
tation and in mathematics. The structure of the generic
frame is clearly visible in a network as a link between
an upper round node and a lower square node. Multiple
contents are multiple lower links. Deletion of structure
is just disconnecting a link. Even the inverter diamond
fits naturally into the patterns of flow. Networks support
any number of types of container.
Unlike the enclosure dialects, networks do not require
multiple replicas of variables. We can use a single node
for each variable, and access the variable through mul¬
tiple links, or pointers. The forms of Arrangement and
Replication in Figure 13-6 show this feature clearly. The
experience of driving on roads between different cities
provides familiarity to the network approach of no rep¬
licated objects.
The fluidity of object and reference in networks can be
expressed as a transformation rule that is unique to this
(and similar) dialects, structure sharing. In structure
sharing, nodes in a network that share the same linking
structure can be joined into a single node with multiple
links. Entire subnetworks are replaced by links to shared
319Chapter 13
-
®
structure. Structure sharing is not available in textual
dialects. The textual representation ot each of the above
forms is ([A])([A]). Multiple occurrence of the same
variable in a textual dialect emulates shared structure
in a network dialect. The absence of structure sharing
in symbolic mathematics has lead to rampant replication
of symbols and a presumption that replication is free. As
noted in Chapter 9, replication is the source of complexity.
Not only is notation not independent of meaning, it can
also actively determine meaning. There is little structure
sharing in the physical world since all physical objects are
unique.8 If two sheets of paper have the same sentence
written on them, then the two virtual sentences share the
same structure. However, the two physical sheets of paper
do not share the same structure (i.e. they are not replicas)
although they may share abstract properties such as use,
color, shape, even content. Representational systems that
lack structure sharing risk confusing features of the sym¬
bol ic model with features of the physical circumstance
being modeled.
#+end_quote

** Overall System Concept
We are building an interactive tutor, scratch pad, and calculator for James Algebra.
James Algebra is a pattern-based formal system with rich variety for visual dialects, from 1d parens, 2d boxes/maps, 2d/experiential paths/rooms, and 3d rooms.

Key features
- Interactive and animated sandbox system playing with James Algebra in multiple dialects
- Has features similar to existing programming language sandboxes / interactive playgrounds:
  - Gallery of examples to play around with
  - Saving and loading programs
- Challenges to manipulate forms together to practice calculation
- James Algebra <> Conventional Algebra translator

#+begin_quote
A dominant characteristic ot boundary forms is the
point-of-view of the reader/participant. Forms can be
read from the outside, objectively, or from the inside, sub¬
jectively. Subjective reading includes participation within
the form itself. Linear form, in contrast, lacks an inside,
forcing the perspective that the reader is outside, in some
higher dimension. In its desire to remove human bias,
mathematics has embraced the outside, objective view¬
point, creating a notation that lacks both participation
and dynamics. Process must then be exhibited as steps.
A refinement that appears to have been overlooked is
that objectivity, seeing things as objects, viewing reality
from the outside, does not achieve neutrality. Objectivity
limits our perspective so severely that we bel leve we are
not only super-human but that we have access to locations
outside of our universe!
Objectivity makes us the outermost boundary.

#+end_quote

List of Dialects
#+begin_example
1d
Parens

2d
enclosures
buckets
blocks
maps
centered maps

experiential
paths
rooms with doors

3d
blocks
#+end_example

** Glossary
- James Algebra
- James Form, or Form
- Sandbox
- Program
- User

** 1. Core User Flows
A user lands on the index page, which is a simple landing page and a link to the sandbox.
When they click on the sandbox, are greeted with the empty sandbox page with a simple James Form.

** 2. Data Model
The canonical data representation should be a tree. The central (in fact, only) relation in James Algebra is that of /containment/, which is also analogous to /child-of/. This is why I am considering tau-prolog. But pattern matching also works too. Maybe for straightforwardness we should just use JS object trees.

#+begin_example js
// void
let universe = []

// ()
let universe = [{boundary: round, children: []}]

// []
let universe = [{boundary: square, children: []}]

// ([])
let universe = [{boundary: round, children: [
  {boundary: square, children: []}
]}]

// [()]
let universe = [{boundary: square, children: [
  {boundary: round, children: []}
]}]

// Inversion Axiom
// From any location where there is nothingness you can create something, so this isn't even quite right.
// You dont need to specify a form which to enfold, you can enfold empty space. If you can find
// a better approach, be my guest.
function enfold(form: Form | null): Form {
// example input: inputForm = childForm | null
// case a: return {form: round, children: [{boundary: square, children: [childForm]}]}
// case b: return {form: round, children: [{boundary: square, children: [childForm]}]}
}

// Both ([]) and [()] should be clarified
function clarify(form: Form): Form | null {
// case a: form = {boundary: round, children: [{boundary: square, children: [childForm]}]}
// case b: form = {boundary: square, children: [{boundary: round, children: [childForm]}]}
// return childForm
}


// Arrangement Axiom
function collect(forms: Form[]): Form {
// N forms, as long as all forms other than the square-children to collect into one frame are shared.
// forms = [
// {boundary: round, children: [...frame, {boundary: square, children: [childFormA]}]}
// {boundary: round, children: [...frame, {boundary: square, children: [childFormB]}]}
// {boundary: round, children: [...frame, {boundary: square, children: [childFormC, childformD]}]}
// ]
// Not all of the forms need to be merged all the time, so maybe we also want a more granular version of collect later.
// return {boundary: round, children: [...frame, {boundary: square, children: [childFormA, childFormB, childFormC, childformD]}]}
}

function disperse(form: Form): Forms[]{
// return {boundary: round, children: [...frame, {boundary: square, children: [childFormA, childFormB, childFormC, childformD]}]}
// 
// N forms, as long as all forms other than the square-children to collect into one frame are shared.
// return [
// {boundary: round, children: [...frame, {boundary: square, children: [childFormA]}]}
// {boundary: round, children: [...frame, {boundary: square, children: [childFormB]}]}
// {boundary: round, children: [...frame, {boundary: square, children: [childFormC, childformD]}]}
// ]
}


// Reflection Axioms
function cancel(forms: Form[]): null {
// Only if the forms annihilate each other
}

function create(): Form[]{
// Create a pair of annihilating forms
// return [
// {boundary: roundOrSquare, children: [..._]}]}
// {boundary: angle, {boundary: roundOrSquare, children: [..._]}]}}
// ]
}
#+end_example

One thing I'm curious about is whether in this example (and vice versa for the other one)
    from: container("square", [container("round", [varRef("$A")])]),

the child for container("round", [varRef("$A")]), namely [varRef("$A")] should be actually a varRef to an entire forest.

what a “form” is, afaict:
- forest := list of nodes (possibly empty). empty forest = void.
- node := round(forest) | square(forest) | angle(forest).
- unit := round([]).
- existence: [round([])] != []. i.e. unit ≠ void.
- unit accumulation: [round([]), round([])] ≠ [round([])]. adjacency is literal concatenation, no idempotence.
- inversion: round([square(a)]) ↔ a and square([round(a)]) ↔ a, where a is any forest (could be []).
  - note: additionally, need the ability to create a void inversion from nothing, i.e, allowing this to be placed /into any/ forest, not just /around/ an existing forest.
- arrangement: round(a ⧺ [square(bs)]) ↔ map b∈bs: round(a ⧺ [square([b])]) as siblings. i.e. duplicate the surrounding context across the square’s children.
- reflection: a ⧺ [angle(a)] ↔ [] and [angle(a)] ⧺ a ↔ [] (a is any forest; this cancels a chunk next to its angled copy).
  
Because, it should be the case that any number of forms surrounded by [()],

e.g. [( () () () [()] )]
would clarify to -> () () () () [()] by removing the outer border. and in this current situation, what would [varRef("$A")] refer to?


From [[file:README.org_archive::*Single Variable Calculus][Single Variable Calculus]], which is NOT for James Algebra, but has a very similar formal system, William Bricken specifies that distinction networks are the only satisfactory computational representation of Laws of Form because it is also iconic. James Algebra is also iconic, and therefore we will need to implement this as a distinction network.



** 3. Architecture Diagram
*** Webserver Architecture
Client :: The key feature right now. Primary feature is a specific page to serve a live sandbox with sidebar for meta-information. React Router and embeds Sandbox.
Server :: Minimal for now; only serves routes. React Router Framework.
Database :: May hold a catalogue of examples, showcases. Likely Supabase.

*** Client
**** React Router
I'm just familiar with it, is all.

**** Sandbox Sidebar
- Dialect switching
- James Algebra <> Conventional Algebra translation
- History
**** Sandbox 

- Logic Engine :: James Algebra rule system, state management (undo/redo).
  - =tau-prolog= 
- Geometry Kernel :: Handles geometry and animation logic
  - =flatten-js= 
    - point, vector, line, ray, segment, circle, arc, polygon.
    - Handles spatial queries through Planar Set.
    - find intersections, check inclusion, calculate distance, apply affine transformation, perform boolean operation.
    - All classes export to SVG.
- Renderer :: Renders to screen
  - =d3js= explicitly supported by =flatten-js=, other graphic libraries would require additional work to bridge
*** Server
**** React Router Framework
**** ORM: Drizzle to interface with Supabase.
*** Database
**** Supabase
** 4. API Sketch
* Current Gameplan

current situation
We do not have enough time for new features -- it is only two hours until demo time and so what we're gonna do is instead take examples from the iconic arithmetic book and lay them out like we have the enfolding sequences and then step through that as a learning / teaching experience for our audience who will have no clue what James algebra is or how it corresponds to Conventional algebra.

so our goal here today is to Add hard-coded sequences and display additional information on the sandbox page that will help clarify what is going on in a given situation or given configuration of the James algebra form

Several features that we need
- Include a legend which explains how each container maps to enter multiple interpretations of arithmetic values
  - But we want to focus on the most obvious interpretation
- We also need to display the conventional algebraic interpretation of the form quite prominently and in a way that is I guess sort of Spatially mapped to the James algebra, but we're not gonna do anything fancy
  - We're just gonna literally have it hard-coded on the demo page as a way to show how each general form Maps to a algebraic interpretation

I need to persuade people that whatever they are seeing is legitimately an algebraic expression.

** I also need to begin preparing a presentation script.
The demo is only three minutes, so it will have to be very quick, and we will separate it in halves.

*** First, sort of an introduction into the concept of James algebra and how to read it. 

  
its purpose and how it fits into the world of existing algebra and mathematics. Also, a mention of the current problem, which is that one-third of American adults do not understand fractions and this is not only due to political or economic constraints, but also due to the crisis in confidence of visual proof from the last 200 years.


**** Quotes from the book I think are relevant

#+begin_quote
The great success of the entirely symbolic approach, fol¬
lowed closely by the rise of the use of streams of ones
and zeros in digital computers, has led to the expression
of mathematics almost exclusively in symbolic string
languages. Unfortunately, in the rush to make math
8symbolic, the early twentieth century founders seem to
have forgotten that people care about understanding and
using math, not about an esoteric collection of structural
rules that cast common arithmetic into conformity with
a maze of symbolic concepts delineated by group theory
built on top of set theory built on top of predicate logic.
...despite the obvious importance of visual images
in human cognitive activities, visual representation
remains a second-class citizen in both the theory
and practice of mathematics.9

-----


A premiere example of a physically dysfunctional sym¬
bolic concept is the associative law of addition.
(a + b) + c = a + (b + c)
The parentheses used to assert this law create visual
interference that undermines the meaning of addition,
that of putting together. Putting things together two-
at-a-time is not a property of addition. The associative
law specifies a method to achieve addition, one that is
not particularly efficient. The sequential two-at-a-time
strategy might be because there are two sides to a tex¬
tual plus sign; it might be because addition tables are
constructed in planar space to add only two numbers at
a time; it might be because relations are usually binary;
it might be because group theory incorporates right- and
left-side rules; or it might be a hangover from counting
by adding one at a time. But here’s what we can learn
from children. To add many things, put them together. It
doesn’t matter how.

-----


Symbolic math is a big part ol the problem ol math educa¬
tion; another big part is our cultural belie! that all people
should learn the details ol an esoteric discipline at the cost
of their own sell-confidence. We may find that symbolic
abstraction is a weakness as well as a strength. When it
comes to problem solving, we might find that symbolic
arithmetic is an antiquated tool. We might find that iconic
arithmetic provides greater elegance, simplicity, ground¬
edness, and hopefully ease of learning.

-----

Our senses and our bodies are the interface between
manifest and conceptual. Distinction is the ground of
perception. When there is no distinction between inside
and outside, we do not perceive a difference. The interface
between our physical and our cognitive selves is a bound¬
ary that transacts only differences. The physicality of our
body defines an obvious container of our self. Boundary
math carries th is physicality, via iconic representation,
directly into the core of mathematical thinking.

-----


 It is time to reclaim mathematics as a human activity, to tame the creature we have unleashed. Humane math aligns with how our minds are known to work, with how the patterns of communication between people work, and with how physical existence embodies our knowledge. Boundary math is both humane and rigorous, the two objectives are not incompatible. The result is a much sim¬ pler iconic arithmetic that reflects how numbers evolved in human cognition prior to our recent truly exotic exper¬ iment with purely symbolic mathematical form. 
#+end_quote

*** And secondly, going through basic equations and practicing the evaluation of it.


This will require both the introduction and clarification of James' algebra as opposed to unit-ensemble arithmetic, which is the way that humans have historically performed math. Instead, I need to compare this to the algebraic equation manipulations, the structure manipulations that we are performing. Unlike the abacus, which assists with calculation of how many, James' algebra and its representations assist with the calculation and transformation of patterns in how to represent or what is the meaning.

Actually, no, it might be best to just jump into it straight in.

And we definitely need to prioritize including the sequence examples.

**** A bunch of examples.


***** Sequences

fig 11-4 p. 278
#+begin_quote
4 + 2 :: oooo oo
 6 :: oooooo



4 - 2 :: oooo <oo>
2 :: oo


4 * 2 ::
([oooo][oo])
([oooo][o]) ([oooo][o])
([oooo]) ([oooo])
oooo oooo
::
8
 

4 / 2 ::
([oooo]<[oo]>)
([oo]<[oo]>) ([oo]<[oo]>)
( ) ( ) ::
2
 

4 ^ 2 ::
(([[oooo]][oo]))
(([[oooo]][o]) ([[oooo]][o]))
([oooo] [o]) ([oooo] [o]) ([oooo] [o]) ([oooo] [o])
([oooo] ) ([oooo] ) ([oooo] ) ([oooo] )
oooo oooo oooo oooo
:: 16

sqrt(4) = 4^(1/2) ::

(( [[ oo oo ]] <[oo]>))
(( [[ ([oo][o]) ([oo] [o]) ]] <[oo]>))

(( [[ ([oo][oo]) ]] <[oo]>))

(( [[oo][oo]] <[oo]>))

(([([[oo]][oo])]<[oo]>))

(( [[oo]] [oo] <[oo]>))

(( [[oo]] ))

oo 
:: 2
#+end_quote



***** Some expressions
#+begin_quote
fig. 11-1 263
expression :: james form

In this, we use numerals as shorthand. 

- 0 :: 
- 3 :: ooo
- -3 :: <3>
- 1/3 :: (<[3]>)
- 3/4 :: ([3][4])


- 2 3/4 :: 2 ([3]<[4]>)
- 3^2 * 5 :: ([5] ([[3]][2]))

explicit base 2
- 1101 :: ([2 o][2][2]) o
implicit base 2
- 1101 :: (((o) o)) o

irrational
- sqrt(3) :: (([[3]]<[2]>))
- e, transcendental base-e :: (o)

  
imaginary and non-numeric forms
- J, the James imaginary log(-1) :: [<o>]
- i, imaginary sqrt(1) :: (([J]<[2]>))

- pi, transendental :: ([J]([J]<[2]>))

- negative infinity :: []
- positive infinity :: <[]>
#+end_quote


***** More Expressions
#+begin_quote
expression :: james form
Inverse
- A :: A
- -A ::: <A>
- 1 / A :: (<[A]>)

Arithmetic
- A + B :: A B
- A - B :: A <B>
- A * B :: ([A][B])
- A / B :: ([A]<[B]>)

Base
- B^A :: (([[B]])[A])
- B^(-A) :: (([[B]])[<A>])
- B ^ (1/A) :: (([[B]]<[A]>))
- log_b (A) :: (<[[B]]>[[A]])

Embedded Base
- # :: (o)
- #^A :: (A)
- log_# (A) :: [A]

#+end_quote




This might be a lot, actually. I think I can maybe include some screenshots of unit ensemble arithmetic, but I'm not sure.


** Other Draft Thoughts

I do feel like it is a little ironic for Void to be explicitly represented with the root node, so I'm wondering if that should maybe be represented by something more reminiscent of a blank canvas? I think maybe going with the qiupu motif.

Demo Priorities 
Priority feature:
- Display the conventional algebraic interpretation of the form prominently.
- I need a *legend*
  - Explain how each container maps to multiple interpretations of arithmetic values in the most obvious way.

*** Demo Sequences (Fig. 11-4)
These walkthroughs script the arithmetic examples we’ll feature in the demo. Each step pairs the James form with a plain-language cue and the matching conventional algebra expression.

**** Addition :: 4 + 2 → 6
1. Separate the two piles so the audience sees each addend.
   #+begin_example
   oooo oo
   #+end_example
2. Merge all marks into one container to show the total.
   #+begin_example
   oooooo
   #+end_example
Conventional anchor: `4 + 2 = 6`
Narration cue: “Addition is just putting everything into one collection.”

**** Subtraction :: 4 − 2 → 2
1. Start with the minuend and show the subtrahend as an inverted pair beside it.
   #+begin_example
   oooo <oo>
   #+end_example
2. Cancel the inverted pair to reveal what remains.
   #+begin_example
   oo
   #+end_example
Conventional anchor: `4 − 2 = 2`
Narration cue: “Subtraction cancels what you mark in contrast.”

**** Multiplication :: 4 × 2 → 8
1. Present the product as a square container of a four-mark frame repeated twice.
   #+begin_example
   ([oooo][oo])
   #+end_example
2. Split the square’s contents so each factor copies the four-mark frame.
   #+begin_example
   ([oooo][o]) ([oooo][o])
   #+end_example
3. Clarify the interior squares to leave paired round frames.
   #+begin_example
   ([oooo]) ([oooo])
   #+end_example
4. Unroll each frame into a flat line of marks.
   #+begin_example
   oooo oooo
   #+end_example
Conventional anchor: `4 × 2 = 8`
Narration cue: “Multiplication is repeated arrangement of the same frame.”

**** Division :: 4 ÷ 2 → 2
1. Frame the dividend with an inverted divisor to show division as sharing.
   #+begin_example
   ([oooo]<[oo]>)
   #+end_example
2. Clarify to two identical sharing frames.
   #+begin_example
   ([oo]<[oo]>) ([oo]<[oo]>)
   #+end_example
3. Resolve each frame to a single unit form.
   #+begin_example
   () ()
   #+end_example
Conventional anchor: `4 ÷ 2 = 2`
Narration cue: “Division is giving each recipient the same clarified share.”

**** Exponentiation :: 4 ^ 2 → 16
1. Show the power as a base frame with its exponent nested inside.
   #+begin_example
   (([[oooo]][oo]))
   #+end_example
2. Duplicate the exponent frame to expose two identical copies of the base.
   #+begin_example
   (([[oooo]][o]) ([[oooo]][o]))
   #+end_example
3. Expand each exponent copy into four framed factors.
   #+begin_example
   ([oooo] [o]) ([oooo] [o]) ([oooo] [o]) ([oooo] [o])
   #+end_example
4. Clarify the square brackets to isolate the base frames.
   #+begin_example
   ([oooo]) ([oooo]) ([oooo]) ([oooo])
   #+end_example
5. Unroll the frames into four groups of four marks.
   #+begin_example
   oooo oooo oooo oooo
   #+end_example
Conventional anchor: `4^2 = 16`
Narration cue: “Exponentiation is multiplying the base by itself as many times as the exponent indicates.”

**** Square Root :: √4 → 2
1. Present the reciprocal exponent frame for the square root.
   #+begin_example
   (([[oooo]]<[oo]>))
   #+end_example
2. Decompose the four into paired square frames under the reciprocal.
   #+begin_example
   (([[oo][oo]]<[oo]>))
   #+end_example
3. Focus on the shared structure within the reciprocal frame.
   #+begin_example
   (([([[oo]][oo])]<[oo]>))
   #+end_example
4. Cancel the reciprocal, leaving a base frame with paired units.
   #+begin_example
   (([[oo]][oo]))
   #+end_example
5. Clarify the interior to a single framed pair of marks.
   #+begin_example
   (([[oo]]))
   #+end_example
6. Enfold to expose the two remaining marks.
   #+begin_example
   oo
   #+end_example
Conventional anchor: `√4 = 2`
Narration cue: “Roots unwind exponent frames until only the shared factor remains.”

*** Demo Script Outline (3 minutes)
**** Hook & Stakes (0:30)
- Open with the crisis in visual proof and the statistic that a third of adults struggle with fractions.
- Establish James Algebra as “math that looks like what it means,” quoting the book’s critique of symbolic overload.
- Invite the audience to treat the demo as a visual proof experiment.

**** Legend & Reading Lesson (0:45)
- Point at the legend: round = unit, square = grouping/multiplication context, angle = inversion/cancellation.
- Walk through the addition sequence’s first frame to show how containers encode relationships, not symbols.
- Emphasize that void space is meaningful—anything outside a boundary is “not inside” that thought.

**** Arithmetic Walkthrough (1:15)
- Addition: show the merge from two piles to one (`4 + 2` cue).
- Subtraction: highlight the inverted pair cancelling to leave `2`.
- Multiplication and Division: contrast the repeated frame with the shared split.
- Exponent and Root: describe how exponent frames iterate and how the root unwinds the same frame.
- Throughout, keep the conventional algebra anchor visible under each step so the audience can ground what they see.

**** Close & Next Steps (0:30)
- Recap: “You just watched arithmetic happen as geometry.”
- Invite feedback on which dialect is most intuitive for them and pitch the roadmap toward interactive sandboxes.
- End on the humane math quote: reclaim math as a human activity, then thank and hand off to questions.



