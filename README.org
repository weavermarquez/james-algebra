#+title: Readme


* Iconic Arithmetic
Based off the work by George Spencer Brown, William Bricken, and Jeffrey James. 
https://iconicmath.com/
https://wbricken.com/



* Gameplan

- Logical Representation :: James Algebra rule system
  - =tau-prolog= 
- Geometry Kernel :: Handles geometry and animation logic
  - =flatten-js= 
    - point, vector, line, ray, segment, circle, arc, polygon.
    - Handles spatial queries through Planar Set.
    - find intersections, check inclusion, calculate distance, apply affine transformation, perform boolean operation.
    - All classes export to SVG.

      #+begin_quote

      #+end_quote
- Renderer :: Renders to screen
  - =d3js= explicitly supported by =flatten-js=, other graphic libraries would require additional work to bridge
* Codex
** goal
valerie is designing a tech implementation of **james algebra**, which has multiple visual dialects (1d parens → 2d boxes/maps → 2d-3d paths/rooms → 3d blocks). entity counts are small (tens–hundreds), so performance is irrelevant; clarity, geometry, and morph animation matter most.

** key conclusions

**rendering**
- pick **one svg-based renderer**: either `react+svg` or `two.js (svg mode)`.
- skip pixi/konva/p5 unless doing future experiential/3d stuff.
  
**geometry kernels**

- **flatten-js**: handle polygons, boxes, networks, merges/splits. pairs neatly with d3/svg.
- **bezier-js**: handle curved “path” dialect; proper bezier math + handles.
- optional: **clipper2-wasm** if you later need robust polygon offsets.
  
**what to avoid**
- d3, pixi, konva, p5 all lack solid boolean geometry; fine for drawing only.
- paper.js too heavyweight unless you want full editor scaffolding.
  
**morph animation strategy**

1. normalize path orientation/winding.
2. resample both shapes to N evenly spaced points (arc-length).
3. align start points to minimize total distance.
4. interpolate points (lerp) → rebuild svg path each frame.
5. for split/merge, manage ghost points / progressive re-sampling.

**architecture**

- **core algebra** (rewrite logic) → **geometry kernel** (flatten/bezier) → **renderer adapter** (svg).
- one morph/tween module reused across dialects.
- kernels hidden behind small interface: `union`, `subtract`, `sample`, `closestPoint`, `tween`.

** tl;dr

→ keep a single svg renderer
→ use **flatten-js** for straight geometry
→ use **bezier-js** for curved dialects
→ animate via resampling and point interpolation
→ reserve konva/pixi/godot for later experiential modes


